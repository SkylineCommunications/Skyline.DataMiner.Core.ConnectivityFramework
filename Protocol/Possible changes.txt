Changes to the 900-1000 lines of code before, now is 900-994

ConnectivityConnection matchingConnection = elementConnections.FindValue(indexer, uniqueKey).FirstOrDefault();
ConnectivityConnection newDestinationConnection = null;
int sourceId = -1;
int destinationId = -1;
bool updated = true;

string connectionType = internalConnection ? "Internal" : "External";
string sourceKey = currentRequest.Source.ElementKey;
string destinationKey = currentRequest.Destination.ElementKey;

string logMessage = $"QA{protocol.QActionID}|DCF Connection|Adding {connectionType} Connection:{currentRequest.CustomName} | With Connection Filter: {currentRequest.ConnectionFilter}";

if (!internalConnection)
{
    logMessage += $" | from Element:{sourceKey} To Element:{destinationKey}";
}

DebugLog(logMessage, LogType.Allways, LogLevel.NoLogging, DcfLogType.Change);

bool operationResult = false;

if (matchingConnection == null)
{
    // Add a new Connection
    if (!currentRequest.Async)
    {
        operationResult = internalConnection
            ? currentRequest.Source.AddConnection(currentRequest.CustomName, currentRequest.CustomName, currentRequest.Destination, currentRequest.ConnectionFilter, false, out matchingConnection, out newDestinationConnection, 420000)
            : currentRequest.Source.AddConnection(currentRequest.CustomName, currentRequest.CustomName + " -RETURN", currentRequest.Destination, currentRequest.ConnectionFilter, currentRequest.CreateExternalReturn, out matchingConnection, out newDestinationConnection, 420000);
    }
    else
    {
        operationResult = internalConnection
            ? currentRequest.Source.AddConnection(currentRequest.CustomName, currentRequest.CustomName, currentRequest.Destination, currentRequest.ConnectionFilter, false, out sourceId, out destinationId)
            : currentRequest.Source.AddConnection(currentRequest.CustomName, currentRequest.CustomName + " -RETURN", currentRequest.Destination, currentRequest.ConnectionFilter, currentRequest.CreateExternalReturn, out sourceId, out destinationId);
    }

    if (!operationResult)
    {
        string logErrorType = internalConnection ? "-sync" : "-async";
        string logErrorMessage = internalConnection
            ? $"QA{protocol.QActionID}: |ERR: DCF Connection|Adding {connectionType} DCF Connection{logErrorType}:{currentRequest.CustomName} on element {sourceKey} Timed-Out after 7 minutes or returned false. Connection may not have been added"
            : $"QA{protocol.QActionID}:|ERR: DCF Connection|Adding External DCF Connection:{currentRequest.CustomName} from element {sourceKey} to element {destinationKey} Timed-Out after 7 minutes or returned false. Connection may not have been added";

        protocol.Log(logErrorMessage, LogType.Error, LogLevel.NoLogging);
    }
}
else
{
    // Update the Connection
    bool updateRequired = matchingConnection.ConnectionName != currentRequest.CustomName ||
        matchingConnection.SourceDataMinerId + "/" + matchingConnection.SourceElementId != sourceKey ||
        matchingConnection.SourceInterfaceId != currentRequest.Source.InterfaceId ||
        matchingConnection.DestinationDMAId + "/" + matchingConnection.DestinationEId != destinationKey ||
        matchingConnection.DestinationInterfaceId != currentRequest.Destination.InterfaceId ||
        matchingConnection.ConnectionFilter != currentRequest.ConnectionFilter;

    if (!updateRequired)
    {
        updated = false;
        string logMessageType = internalConnection ? "Internal" : "External";
        string logMessageSame = internalConnection
            ? $"QA{protocol.QActionID}|DCF Connection ({matchingConnection.ConnectionId}) | Not Updating {logMessageType} Connection (ID:{matchingConnection.ConnectionId}) To:{currentRequest.CustomName} on Element:{sourceKey} -- No Change Detected"
            : $"QA{protocol.QActionID}|DCF Connection ({matchingConnection.ConnectionId}) | Not Updating {logMessageType} Connection (ID:{matchingConnection.ConnectionId}) To:{currentRequest.CustomName} from Element:{sourceKey} To Element:{destinationKey} -- No Change Detected";

        DebugLog(logMessageSame, LogType.Allways, LogLevel.NoLogging, DcfLogType.Same);
    }
    else
    {
        string logMessageType = internalConnection ? "Internal" : "External";
        string logMessageChange = internalConnection
            ? $"QA{protocol.QActionID}|DCF Connection ({matchingConnection.ConnectionId}) | Updating {logMessageType} Connection (ID:{matchingConnection.ConnectionId}) To:{currentRequest.CustomName} | With Connection Filter: {currentRequest.ConnectionFilter} | on Element:{sourceKey}"
            : $"QA{protocol.QActionID}|DCF Connection ({matchingConnection.ConnectionId}) | Updating {logMessageType} Connection (ID:{matchingConnection.ConnectionId}) To:{currentRequest.CustomName} | With Connection Filter: {currentRequest.ConnectionFilter} | from Element:{sourceKey} To Element:{destinationKey}";

        DebugLog(logMessageChange, LogType.Allways, LogLevel.NoLogging, DcfLogType.Change);

        operationResult = internalConnection
            ? matchingConnection.Update(currentRequest.CustomName, currentRequest.Source.InterfaceId, currentRequest.CustomName, currentRequest.Destination.DataMinerId, currentRequest.Destination.ElementId, currentRequest.Destination.InterfaceId, currentRequest.ConnectionFilter, false, out newDestinationConnection, 420000)
            : matchingConnection.Update(currentRequest.CustomName, currentRequest.Source.InterfaceId, currentRequest.CustomName + " -RETURN", currentRequest.Destination.DataMinerId, currentRequest.Destination.ElementId, currentRequest.Destination.InterfaceId, currentRequest.ConnectionFilter, currentRequest.CreateExternalReturn, out newDestinationConnection, 420000);

        if (!operationResult)
        {
            string logErrorType = internalConnection ? "Internal" : "External";
            string logErrorMessage = internalConnection
                ? $"QA{protocol.QActionID}|ERR: DCF Connection ({matchingConnection.ConnectionId}) | Updating {logErrorType} DCF Connection:{currentRequest.CustomName} on element {sourceKey} Timed-Out after 7 minutes or returned false. Connection may not have been updated"
                : $"QA{protocol.QActionID}|ERR: DCF Connection ({matchingConnection.ConnectionId}) | Updating {logErrorType} DCF Connection:{currentRequest.CustomName} from element {sourceKey} to element {destinationKey} Timed-Out after 7 minutes or returned false. Connection may not have been updated";

            protocol.Log(logErrorMessage, LogType.Error, LogLevel.NoLogging);
        }
    }
}

if (matchingConnection != null) sourceId = matchingConnection.ConnectionId;
if (newDestinationConnection != null) destinationId = newDestinationConnection.ConnectionId;


FULL UPDATE 809-1052

 HashSet<int> uniqueConnectionIDs = new HashSet<int>(connectionIDs);

                foreach(int connectionID in uniqueConnectionIDs)
                {
                    var con = input.GetConnectionById(connectionID);

                    if(!force &&
                       !managedCurrentByThisProtocol.Contains(connectionID) &&
                       !managedCurrentByThisProtocol.Contains(-connectionID) &&
                       !managedNewByThisProtocol.Contains(connectionID) &&
                       !managedNewByThisProtocol.Contains(-connectionID))
                    {
                        continue;
                    }

                    DebugLog($"QA{protocol.QActionID}|DCF Connection ({con.ConnectionId})|Deleting Connection:{con.ConnectionName}", LogType.Allways, LogLevel.NoLogging, DcfLogType.Change);

                    if(input.DeleteConnection(connectionID, bothConnections))
                    {
                        managedNewByThisProtocol.Remove(connectionID);
                        managedCurrentByThisProtocol.Remove(connectionID);
                        managedNewByThisProtocol.Remove(-connectionID);
                        managedCurrentByThisProtocol.Remove(-connectionID);
                    }

                    else
                    {
                        protocol.Log($"QA{protocol.QActionID}:|ERR: DCF Connection ({connectionID})|Removing DCF Connection:{con.ConnectionName} Returned False. Connection may not have been Removed", LogType.Error, LogLevel.NoLogging);
                        finalResult = false;
                    }
                }


try
{
    long millisecondsToWait = secondsToWait * 1000;
    long startTime = sw.ElapsedMilliseconds;

    while (!interfacesPresent && sw.ElapsedMilliseconds - startTime < millisecondsToWait)
    {
        try
        {
            interfacesDictionary = protocol.GetConnectivityInterfaces(localDMAID, localEleID);
            HashSet<string> allInterfaceKeys = new HashSet<string>(interfacesDictionary
                .Where(p => p.Value.ElementKey == thisElementKey && p.Value.DynamicLink == parameterGroupID)
                .Select(p => p.Value.DynamicPK));

            bool currentInterfacesPresent = oKeys.Length == allInterfaceKeys.Count && oKeys.All(oKey => allInterfaceKeys.Contains(Convert.ToString(oKey)));

            if (!currentInterfacesPresent)
            {
                Thread.Sleep(threadSleepMilliseconds);
            }
            else
            {
                interfacesPresent = true;
            }
        }
        catch (Exception e)
        {
            protocol.Log(string.Format("QA{0}:|ERR: DCF Interface|(Exception) at {1} CheckInterfacesReady: While Loop with Exception:{2}", protocol.QActionID, sw.ElapsedMilliseconds, e.ToString()), LogType.Error, LogLevel.NoLogging);
            // Consider adding a retry mechanism here if exceptions are expected.
        }
    }

    if (interfacesPresent)
    {
        var allInterfaces = new FastCollection<ConnectivityInterface>(interfacesDictionary.Values.ToArray());
        cachedInterfacesPerElement[localElementKey] = allInterfaces;
    }
}
catch (Exception e)
{
    protocol.Log(string.Format("QA{0}:|ERR: DCF Interface|(Exception) at CheckInterfacesReady with Exception:{1}", protocol.QActionID, e.ToString()), LogType.Error, LogLevel.NoLogging);
}

693-719

if (request.DestinationInterface != null)
{
    indexer = p => InternalExternalChar(p, request.Type) + "_" +
        (request.SourceInterface != null
            ? $"{p.SourceInterfaceId}/{p.DestinationDMAId}/{p.DestinationEId}/{p.DestinationInterfaceId}"
            : $"{p.DestinationDMAId}/{p.DestinationEId}/{p.DestinationInterfaceId}");
    uniqueKey = internalExternal + "_" +
        (request.SourceInterface != null
            ? $"{request.SourceInterface.InterfaceId}/{request.DestinationInterface.ElementKey}/{request.DestinationInterface.InterfaceId}"
            : $"{request.DestinationInterface.DataMinerId}/{request.DestinationInterface.ElementId}/{request.DestinationInterface.InterfaceId}");
}
else if (request.SourceInterface != null)
{
    indexer = p => InternalExternalChar(p, request.Type) + "_" + p.SourceInterfaceId;
    uniqueKey = internalExternal + "_" + Convert.ToString(request.SourceInterface.InterfaceId);
}
else
{
    indexer = p => InternalExternalChar(p, request.Type);
    uniqueKey = internalExternal;
}


public bool RemoveConnectionProperties(ConnectivityConnection connection, bool force, params int[] propertyIDs)
{
    try
    {
        if (connection == null)
        {
            protocol.Log(string.Format("QA{0}:|ERR: DCF Connection Property| Remove Connection Properties ConnectivityConnection connection was Null", protocol.QActionID), LogType.Error, LogLevel.NoLogging);
            return false;
        }

        if (currentConnectionPropertyPID == -1)
        {
            protocol.Log("QA" + protocol.QActionID + "|ERR: DCF Connection Property|DCFHelper Error: Using RemoveConnectionProperties requires the CurrentConnectionPropertiesPID to be defined! Please change the Options Objects to include this PID", LogType.Error, LogLevel.NoLogging);
            return false;
        }

        bool success = true;
        string eleKey = CreateElementKey(connection.SourceDataMinerId, connection.SourceElementId);

        if (!IsElementStarted(protocol, eleKey))
        {
            protocol.Log(string.Format("QA{0}: |ERR: DCF Connection Property|Ignoring RemoveConnectionProperties: Unloaded Element:{1} ", protocol.QActionID, eleKey), LogType.Error, LogLevel.NoLogging);
            return false;
        }

        HashSet<int> managedNewByThisProtocol = newConnectionProperties.TryGetValue(eleKey, out var newProps) ? newProps : new HashSet<int>();
        HashSet<int> managedCurrentByThisProtocol = currentConnectionProperties.TryGetValue(eleKey, out var currentProps) ? currentProps : new HashSet<int>();

        foreach (int propertyID in propertyIDs)
        {
            if (force || managedNewByThisProtocol.Contains(propertyID) || managedNewByThisProtocol.Contains(-propertyID) || managedCurrentByThisProtocol.Contains(propertyID) || managedCurrentByThisProtocol.Contains(-propertyID))
            {
                DebugLog("QA" + protocol.QActionID + "|DCF Connection Property (" + propertyID + ")|Deleting Connection Property:" + propertyID, LogType.Allways, LogLevel.NoLogging, DcfLogType.Change);

                if (!connection.DeleteProperty(propertyID))
                {
                    success = false;
                    protocol.Log(string.Format("QA{0}:|ERR: DCF Connection Property (" + propertyID + ")| Removing Connection Property:{1} Returned False! Property may not have been Removed!", protocol.QActionID, propertyID), LogType.Error, LogLevel.NoLogging);
                }
                else
                {
                    managedCurrentByThisProtocol.Remove(propertyID);
                    managedNewByThisProtocol.Remove(propertyID);
                    managedCurrentByThisProtocol.Remove(-propertyID);
                    managedNewByThisProtocol.Remove(-propertyID);
                }
            }
        }

        newConnectionProperties[eleKey] = managedNewByThisProtocol;
        currentConnectionProperties[eleKey] = managedCurrentByThisProtocol;
        return success;
    }
    catch (Exception e)
    {
        protocol.Log(string.Format("QA{0}:|ERR: DCF Connection Property|(Exception) Value at {1} with Exception:{2}", protocol.QActionID, "RemoveConnectionProperties", e.ToString()), LogType.Error, LogLevel.NoLogging);
    }

    return false;
}


public DcfConnectionResult[] GetConnections(bool forceRefresh, params DcfConnectionFilter[] requests)
{
    DcfConnectionResult[] result = new DcfConnectionResult[requests.Length];

    for (int i = 0; i < requests.Length; i++)
    {
        var request = requests[i];
        result[i] = null;

        // ... (omitting the logging for brevity)

        // Calculate requestDMAId, requestEleId, and requestElementKey

        int requestDMAId;
        int requestEleId;
        string requestElementKey;

        if (string.IsNullOrEmpty(request.ElementKey))
        {
            requestDMAId = request.SourceInterface?.DataMinerId ?? localDMAID;
            requestEleId = request.SourceInterface?.ElementId ?? localEleID;
            requestElementKey = request.SourceInterface?.ElementKey ?? localElementKey;
        }
        else if (request.ElementKey == "local")
        {
            requestElementKey = localElementKey;
            requestDMAId = localDMAID;
            requestEleId = localEleID;
        }
        else
        {
            string[] splitKey = request.ElementKey.Split('/');
            if (splitKey.Length > 1 && int.TryParse(splitKey[0], out requestDMAId) && int.TryParse(splitKey[1], out requestEleId))
            {
                requestElementKey = request.ElementKey;
            }
            else
            {
                protocol.Log($"QA{protocol.QActionID}: |ERR: DCF Connection|Ignoring GetConnections: Invalid Format ElementKey:{request.ElementKey}", LogType.Error, LogLevel.NoLogging);
                continue;
            }
        }


        // ...

        string internalExternal = GetInternalExternalString(request.Type);

        // ...

        if (!IsElementStarted(protocol, requestElementKey))
        {
            continue;
        }

        // ...

        if (!cachedConnectionPerElement.ContainsKey(requestElementKey) || forceRefresh)
        {
            var newPolledConnections = protocol.GetConnectivityConnections(requestDMAId, requestEleId);
            if (newPolledConnections == null)
            {
                // Handle the case where GetConnectivityConnections returns null
                continue;
            }

            cachedConnectionPerElement[requestElementKey] = new FastCollection<ConnectivityConnection>(newPolledConnections.Values.ToList());
        }

        // ...

        FastCollection<ConnectivityConnection> elementConnections = cachedConnectionPerElement[requestElementKey];
        var foundConnections = FindConnections(elementConnections, indexer, uniqueKey);

        // ...

        if (request.PropertyFilter != null && result[i] != null)
        {
            // ToDo: Write code to filter on connectionProperties
        }
    }

    // Log the result or any other necessary logging
    return result;
}

private string GetInternalExternalString(ConnectionType type)
{
    switch (type)
    {
        case ConnectionType.Internal:
            return "I";
        case ConnectionType.External:
            return "E";
        case ConnectionType.Both:
            return "B";
        default:
            return "B"; // Default to "Both" if the type is not recognized.
    }
}

private ConnectivityConnection[] FindConnections(FastCollection<ConnectivityConnection> elementConnections, Expression<Func<ConnectivityConnection, object>> indexer, string uniqueKey)
{
    if (indexer != null && uniqueKey != null)
    {
        var foundConnections = elementConnections.FindValue(indexer, uniqueKey).ToArray();
        return foundConnections.Length > 0 ? foundConnections : null;
    }
    else
    {
        return elementConnections.Count() > 0 ? elementConnections.ToArray() : null;
    }
}


public bool RemoveConnections(int dataMinerID, int elementID, bool bothConnections, bool force, params int[] connectionIDs)
{
    try
    {
        if (currentConnectionsPID == -1)
        {
            protocol.Log("QA" + protocol.QActionID + "|ERR: DCF Connection|DCFHelper Error: Using RemoveConnections requires the CurrentConnectionsPID to be defined! Please change the Options Objects to include this PID", LogType.Error, LogLevel.NoLogging);
            return false;
        }

        string eleKey = CreateElementKey(dataMinerID, elementID);

        // Early return for unloaded elements
        if (unloadedElements.Contains(eleKey))
        {
            protocol.Log(string.Format("QA{0}: |ERR: DCF Connection|Ignoring RemoveConnections: Unloaded Element:{1} ", protocol.QActionID, eleKey), LogType.Error, LogLevel.NoLogging);
            return false;
        }

        HashSet<int> managedNewByThisProtocol = new HashSet<int>(newConnections.TryGetValue(eleKey, out var newSet) ? newSet : Enumerable.Empty<int>());
        HashSet<int> managedCurrentByThisProtocol = new HashSet<int>(currentConnections.TryGetValue(eleKey, out var currentSet) ? currentSet : Enumerable.Empty<int>());

        // Optimized
        foreach (int connectionID in connectionIDs)
        {
            int absConnectionID = Math.Abs(connectionID);

            if (force || managedCurrentByThisProtocol.Contains(absConnectionID) || managedNewByThisProtocol.Contains(absConnectionID))
            {
                string logMessage = $"QA{protocol.QActionID}|DCF Connection ({absConnectionID}) | Deleting Connection:{absConnectionID}";

                DebugLog(logMessage, LogType.Allways, LogLevel.NoLogging, DcfLogType.Change);

                if (protocol.DeleteConnectivityConnection(absConnectionID, dataMinerID, elementID, bothConnections))
                {
                    managedNewByThisProtocol.Remove(absConnectionID);
                    managedCurrentByThisProtocol.Remove(absConnectionID);
                }
                else
                {
                    string errorMessage = $"QA{protocol.QActionID}: |ERR: DCF Connection ({absConnectionID})| Removing DCF Connection: {absConnectionID} Returned False. Connection may not have been removed";

                    protocol.Log(errorMessage, LogType.Error, LogLevel.NoLogging);
                    finalResult = false;
                }
            }
        }

        newConnections[eleKey] = managedNewByThisProtocol;
        currentConnections[eleKey] = managedCurrentByThisProtocol;

        return finalResult;
    }
    catch (Exception e)
    {
        protocol.Log(string.Format("QA{0}:|ERR: DCF Connection| (Exception) Value at {1} with Exception:{2}", protocol.QActionID, "RemoveConnections", e.ToString()), LogType.Error, LogLevel.NoLogging);
    }

    return false;
}




public bool RemoveConnections(int dataMinerID, int elementID, bool bothConnections, bool force, params int[] connectionIDs)
{
    try
    {
        if (currentConnectionsPID == -1)
        {
            protocol.Log("QA" + protocol.QActionID + "|ERR: DCF Connection|DCFHelper Error: Using RemoveConnections requires the CurrentConnectionsPID to be defined! Please change the Options Objects to include this PID", LogType.Error, LogLevel.NoLogging);
            return false;
        }

        string eleKey = CreateElementKey(dataMinerID, elementID);

        // Early return for unloaded elements
        if (unloadedElements.Contains(eleKey))
        {
            protocol.Log(string.Format("QA{0}: |ERR: DCF Connection|Ignoring RemoveConnections: Unloaded Element:{1} ", protocol.QActionID, eleKey), LogType.Error, LogLevel.NoLogging);
            return false;
        }

        // Retrieve the managed connections sets
        if (!newConnections.TryGetValue(eleKey, out var managedNewByThisProtocol))
        {
            managedNewByThisProtocol = new HashSet<int>();
        }

        if (!currentConnections.TryGetValue(eleKey, out var managedCurrentByThisProtocol))
        {
            managedCurrentByThisProtocol = new HashSet<int>();
        }

        bool finalResult = true;

        // Create a HashSet for faster lookup
        var connectionIDsSet = new HashSet<int>(connectionIDs.Select(Math.Abs));

        foreach (int connectionID in connectionIDsSet)
        {
            if (force || managedCurrentByThisProtocol.Contains(connectionID) || managedNewByThisProtocol.Contains(connectionID))
            {
                string logMessage = $"QA{protocol.QActionID}|DCF Connection ({connectionID}) | Deleting Connection:{connectionID}";

                DebugLog(logMessage, LogType.Allways, LogLevel.NoLogging, DcfLogType.Change);

                if (protocol.DeleteConnectivityConnection(connectionID, dataMinerID, elementID, bothConnections))
                {
                    managedNewByThisProtocol.Remove(connectionID);
                    managedCurrentByThisProtocol.Remove(connectionID);
                }
                else
                {
                    string errorMessage = $"QA{protocol.QActionID}: |ERR: DCF Connection ({connectionID})| Removing DCF Connection: {connectionID} Returned False. Connection may not have been removed";

                    protocol.Log(errorMessage, LogType.Error, LogLevel.NoLogging);
                    finalResult = false;
                }
            }
        }

        newConnections[eleKey] = managedNewByThisProtocol;
        currentConnections[eleKey] = managedCurrentByThisProtocol;

        return finalResult;
    }
    catch (Exception e)
    {
        protocol.Log(string.Format("QA{0}:|ERR: DCF Connection| (Exception) Value at {1} with Exception:{2}", protocol.QActionID, "RemoveConnections", e.ToString()), LogType.Error, LogLevel.NoLogging);
    }

    return false;
}



