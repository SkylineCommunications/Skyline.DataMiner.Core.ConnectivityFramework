Changes to the 900-1000 lines of code before, now is 900-994

ConnectivityConnection matchingConnection = elementConnections.FindValue(indexer, uniqueKey).FirstOrDefault();
ConnectivityConnection newDestinationConnection = null;
int sourceId = -1;
int destinationId = -1;
bool updated = true;

string connectionType = internalConnection ? "Internal" : "External";
string sourceKey = currentRequest.Source.ElementKey;
string destinationKey = currentRequest.Destination.ElementKey;

string logMessage = $"QA{protocol.QActionID}|DCF Connection|Adding {connectionType} Connection:{currentRequest.CustomName} | With Connection Filter: {currentRequest.ConnectionFilter}";

if (!internalConnection)
{
    logMessage += $" | from Element:{sourceKey} To Element:{destinationKey}";
}

DebugLog(logMessage, LogType.Allways, LogLevel.NoLogging, DcfLogType.Change);

bool operationResult = false;

if (matchingConnection == null)
{
    // Add a new Connection
    if (!currentRequest.Async)
    {
        operationResult = internalConnection
            ? currentRequest.Source.AddConnection(currentRequest.CustomName, currentRequest.CustomName, currentRequest.Destination, currentRequest.ConnectionFilter, false, out matchingConnection, out newDestinationConnection, 420000)
            : currentRequest.Source.AddConnection(currentRequest.CustomName, currentRequest.CustomName + " -RETURN", currentRequest.Destination, currentRequest.ConnectionFilter, currentRequest.CreateExternalReturn, out matchingConnection, out newDestinationConnection, 420000);
    }
    else
    {
        operationResult = internalConnection
            ? currentRequest.Source.AddConnection(currentRequest.CustomName, currentRequest.CustomName, currentRequest.Destination, currentRequest.ConnectionFilter, false, out sourceId, out destinationId)
            : currentRequest.Source.AddConnection(currentRequest.CustomName, currentRequest.CustomName + " -RETURN", currentRequest.Destination, currentRequest.ConnectionFilter, currentRequest.CreateExternalReturn, out sourceId, out destinationId);
    }

    if (!operationResult)
    {
        string logErrorType = internalConnection ? "-sync" : "-async";
        string logErrorMessage = internalConnection
            ? $"QA{protocol.QActionID}: |ERR: DCF Connection|Adding {connectionType} DCF Connection{logErrorType}:{currentRequest.CustomName} on element {sourceKey} Timed-Out after 7 minutes or returned false. Connection may not have been added"
            : $"QA{protocol.QActionID}:|ERR: DCF Connection|Adding External DCF Connection:{currentRequest.CustomName} from element {sourceKey} to element {destinationKey} Timed-Out after 7 minutes or returned false. Connection may not have been added";

        protocol.Log(logErrorMessage, LogType.Error, LogLevel.NoLogging);
    }
}
else
{
    // Update the Connection
    bool updateRequired = matchingConnection.ConnectionName != currentRequest.CustomName ||
        matchingConnection.SourceDataMinerId + "/" + matchingConnection.SourceElementId != sourceKey ||
        matchingConnection.SourceInterfaceId != currentRequest.Source.InterfaceId ||
        matchingConnection.DestinationDMAId + "/" + matchingConnection.DestinationEId != destinationKey ||
        matchingConnection.DestinationInterfaceId != currentRequest.Destination.InterfaceId ||
        matchingConnection.ConnectionFilter != currentRequest.ConnectionFilter;

    if (!updateRequired)
    {
        updated = false;
        string logMessageType = internalConnection ? "Internal" : "External";
        string logMessageSame = internalConnection
            ? $"QA{protocol.QActionID}|DCF Connection ({matchingConnection.ConnectionId}) | Not Updating {logMessageType} Connection (ID:{matchingConnection.ConnectionId}) To:{currentRequest.CustomName} on Element:{sourceKey} -- No Change Detected"
            : $"QA{protocol.QActionID}|DCF Connection ({matchingConnection.ConnectionId}) | Not Updating {logMessageType} Connection (ID:{matchingConnection.ConnectionId}) To:{currentRequest.CustomName} from Element:{sourceKey} To Element:{destinationKey} -- No Change Detected";

        DebugLog(logMessageSame, LogType.Allways, LogLevel.NoLogging, DcfLogType.Same);
    }
    else
    {
        string logMessageType = internalConnection ? "Internal" : "External";
        string logMessageChange = internalConnection
            ? $"QA{protocol.QActionID}|DCF Connection ({matchingConnection.ConnectionId}) | Updating {logMessageType} Connection (ID:{matchingConnection.ConnectionId}) To:{currentRequest.CustomName} | With Connection Filter: {currentRequest.ConnectionFilter} | on Element:{sourceKey}"
            : $"QA{protocol.QActionID}|DCF Connection ({matchingConnection.ConnectionId}) | Updating {logMessageType} Connection (ID:{matchingConnection.ConnectionId}) To:{currentRequest.CustomName} | With Connection Filter: {currentRequest.ConnectionFilter} | from Element:{sourceKey} To Element:{destinationKey}";

        DebugLog(logMessageChange, LogType.Allways, LogLevel.NoLogging, DcfLogType.Change);

        operationResult = internalConnection
            ? matchingConnection.Update(currentRequest.CustomName, currentRequest.Source.InterfaceId, currentRequest.CustomName, currentRequest.Destination.DataMinerId, currentRequest.Destination.ElementId, currentRequest.Destination.InterfaceId, currentRequest.ConnectionFilter, false, out newDestinationConnection, 420000)
            : matchingConnection.Update(currentRequest.CustomName, currentRequest.Source.InterfaceId, currentRequest.CustomName + " -RETURN", currentRequest.Destination.DataMinerId, currentRequest.Destination.ElementId, currentRequest.Destination.InterfaceId, currentRequest.ConnectionFilter, currentRequest.CreateExternalReturn, out newDestinationConnection, 420000);

        if (!operationResult)
        {
            string logErrorType = internalConnection ? "Internal" : "External";
            string logErrorMessage = internalConnection
                ? $"QA{protocol.QActionID}|ERR: DCF Connection ({matchingConnection.ConnectionId}) | Updating {logErrorType} DCF Connection:{currentRequest.CustomName} on element {sourceKey} Timed-Out after 7 minutes or returned false. Connection may not have been updated"
                : $"QA{protocol.QActionID}|ERR: DCF Connection ({matchingConnection.ConnectionId}) | Updating {logErrorType} DCF Connection:{currentRequest.CustomName} from element {sourceKey} to element {destinationKey} Timed-Out after 7 minutes or returned false. Connection may not have been updated";

            protocol.Log(logErrorMessage, LogType.Error, LogLevel.NoLogging);
        }
    }
}

if (matchingConnection != null) sourceId = matchingConnection.ConnectionId;
if (newDestinationConnection != null) destinationId = newDestinationConnection.ConnectionId;


FULL UPDATE 809-1052

 HashSet<int> uniqueConnectionIDs = new HashSet<int>(connectionIDs);

                foreach(int connectionID in uniqueConnectionIDs)
                {
                    var con = input.GetConnectionById(connectionID);

                    if(!force &&
                       !managedCurrentByThisProtocol.Contains(connectionID) &&
                       !managedCurrentByThisProtocol.Contains(-connectionID) &&
                       !managedNewByThisProtocol.Contains(connectionID) &&
                       !managedNewByThisProtocol.Contains(-connectionID))
                    {
                        continue;
                    }

                    DebugLog($"QA{protocol.QActionID}|DCF Connection ({con.ConnectionId})|Deleting Connection:{con.ConnectionName}", LogType.Allways, LogLevel.NoLogging, DcfLogType.Change);

                    if(input.DeleteConnection(connectionID, bothConnections))
                    {
                        managedNewByThisProtocol.Remove(connectionID);
                        managedCurrentByThisProtocol.Remove(connectionID);
                        managedNewByThisProtocol.Remove(-connectionID);
                        managedCurrentByThisProtocol.Remove(-connectionID);
                    }

                    else
                    {
                        protocol.Log($"QA{protocol.QActionID}:|ERR: DCF Connection ({connectionID})|Removing DCF Connection:{con.ConnectionName} Returned False. Connection may not have been Removed", LogType.Error, LogLevel.NoLogging);
                        finalResult = false;
                    }
                }


try
{
    long millisecondsToWait = secondsToWait * 1000;
    long startTime = sw.ElapsedMilliseconds;

    while (!interfacesPresent && sw.ElapsedMilliseconds - startTime < millisecondsToWait)
    {
        try
        {
            interfacesDictionary = protocol.GetConnectivityInterfaces(localDMAID, localEleID);
            HashSet<string> allInterfaceKeys = new HashSet<string>(interfacesDictionary
                .Where(p => p.Value.ElementKey == thisElementKey && p.Value.DynamicLink == parameterGroupID)
                .Select(p => p.Value.DynamicPK));

            bool currentInterfacesPresent = oKeys.Length == allInterfaceKeys.Count && oKeys.All(oKey => allInterfaceKeys.Contains(Convert.ToString(oKey)));

            if (!currentInterfacesPresent)
            {
                Thread.Sleep(threadSleepMilliseconds);
            }
            else
            {
                interfacesPresent = true;
            }
        }
        catch (Exception e)
        {
            protocol.Log(string.Format("QA{0}:|ERR: DCF Interface|(Exception) at {1} CheckInterfacesReady: While Loop with Exception:{2}", protocol.QActionID, sw.ElapsedMilliseconds, e.ToString()), LogType.Error, LogLevel.NoLogging);
            // Consider adding a retry mechanism here if exceptions are expected.
        }
    }

    if (interfacesPresent)
    {
        var allInterfaces = new FastCollection<ConnectivityInterface>(interfacesDictionary.Values.ToArray());
        cachedInterfacesPerElement[localElementKey] = allInterfaces;
    }
}
catch (Exception e)
{
    protocol.Log(string.Format("QA{0}:|ERR: DCF Interface|(Exception) at CheckInterfacesReady with Exception:{1}", protocol.QActionID, e.ToString()), LogType.Error, LogLevel.NoLogging);
}

693-719

if (request.DestinationInterface != null)
{
    indexer = p => InternalExternalChar(p, request.Type) + "_" +
        (request.SourceInterface != null
            ? $"{p.SourceInterfaceId}/{p.DestinationDMAId}/{p.DestinationEId}/{p.DestinationInterfaceId}"
            : $"{p.DestinationDMAId}/{p.DestinationEId}/{p.DestinationInterfaceId}");
    uniqueKey = internalExternal + "_" +
        (request.SourceInterface != null
            ? $"{request.SourceInterface.InterfaceId}/{request.DestinationInterface.ElementKey}/{request.DestinationInterface.InterfaceId}"
            : $"{request.DestinationInterface.DataMinerId}/{request.DestinationInterface.ElementId}/{request.DestinationInterface.InterfaceId}");
}
else if (request.SourceInterface != null)
{
    indexer = p => InternalExternalChar(p, request.Type) + "_" + p.SourceInterfaceId;
    uniqueKey = internalExternal + "_" + Convert.ToString(request.SourceInterface.InterfaceId);
}
else
{
    indexer = p => InternalExternalChar(p, request.Type);
    uniqueKey = internalExternal;
}


public bool RemoveConnectionProperties(ConnectivityConnection connection, bool force, params int[] propertyIDs)
{
    try
    {
        if (connection == null)
        {
            protocol.Log(string.Format("QA{0}:|ERR: DCF Connection Property| Remove Connection Properties ConnectivityConnection connection was Null", protocol.QActionID), LogType.Error, LogLevel.NoLogging);
            return false;
        }

        if (currentConnectionPropertyPID == -1)
        {
            protocol.Log("QA" + protocol.QActionID + "|ERR: DCF Connection Property|DCFHelper Error: Using RemoveConnectionProperties requires the CurrentConnectionPropertiesPID to be defined! Please change the Options Objects to include this PID", LogType.Error, LogLevel.NoLogging);
            return false;
        }

        bool success = true;
        string eleKey = CreateElementKey(connection.SourceDataMinerId, connection.SourceElementId);

        if (!IsElementStarted(protocol, eleKey))
        {
            protocol.Log(string.Format("QA{0}: |ERR: DCF Connection Property|Ignoring RemoveConnectionProperties: Unloaded Element:{1} ", protocol.QActionID, eleKey), LogType.Error, LogLevel.NoLogging);
            return false;
        }

        HashSet<int> managedNewByThisProtocol = newConnectionProperties.TryGetValue(eleKey, out var newProps) ? newProps : new HashSet<int>();
        HashSet<int> managedCurrentByThisProtocol = currentConnectionProperties.TryGetValue(eleKey, out var currentProps) ? currentProps : new HashSet<int>();

        foreach (int propertyID in propertyIDs)
        {
            if (force || managedNewByThisProtocol.Contains(propertyID) || managedNewByThisProtocol.Contains(-propertyID) || managedCurrentByThisProtocol.Contains(propertyID) || managedCurrentByThisProtocol.Contains(-propertyID))
            {
                DebugLog("QA" + protocol.QActionID + "|DCF Connection Property (" + propertyID + ")|Deleting Connection Property:" + propertyID, LogType.Allways, LogLevel.NoLogging, DcfLogType.Change);

                if (!connection.DeleteProperty(propertyID))
                {
                    success = false;
                    protocol.Log(string.Format("QA{0}:|ERR: DCF Connection Property (" + propertyID + ")| Removing Connection Property:{1} Returned False! Property may not have been Removed!", protocol.QActionID, propertyID), LogType.Error, LogLevel.NoLogging);
                }
                else
                {
                    managedCurrentByThisProtocol.Remove(propertyID);
                    managedNewByThisProtocol.Remove(propertyID);
                    managedCurrentByThisProtocol.Remove(-propertyID);
                    managedNewByThisProtocol.Remove(-propertyID);
                }
            }
        }

        newConnectionProperties[eleKey] = managedNewByThisProtocol;
        currentConnectionProperties[eleKey] = managedCurrentByThisProtocol;
        return success;
    }
    catch (Exception e)
    {
        protocol.Log(string.Format("QA{0}:|ERR: DCF Connection Property|(Exception) Value at {1} with Exception:{2}", protocol.QActionID, "RemoveConnectionProperties", e.ToString()), LogType.Error, LogLevel.NoLogging);
    }

    return false;
}


public DcfConnectionResult[] GetConnections(bool forceRefresh, params DcfConnectionFilter[] requests)
{
    DcfConnectionResult[] result = new DcfConnectionResult[requests.Length];

    for (int i = 0; i < requests.Length; i++)
    {
        var request = requests[i];
        result[i] = null;

        // ... (omitting the logging for brevity)

        // Calculate requestDMAId, requestEleId, and requestElementKey

        int requestDMAId;
        int requestEleId;
        string requestElementKey;

        if (string.IsNullOrEmpty(request.ElementKey))
        {
            requestDMAId = request.SourceInterface?.DataMinerId ?? localDMAID;
            requestEleId = request.SourceInterface?.ElementId ?? localEleID;
            requestElementKey = request.SourceInterface?.ElementKey ?? localElementKey;
        }
        else if (request.ElementKey == "local")
        {
            requestElementKey = localElementKey;
            requestDMAId = localDMAID;
            requestEleId = localEleID;
        }
        else
        {
            string[] splitKey = request.ElementKey.Split('/');
            if (splitKey.Length > 1 && int.TryParse(splitKey[0], out requestDMAId) && int.TryParse(splitKey[1], out requestEleId))
            {
                requestElementKey = request.ElementKey;
            }
            else
            {
                protocol.Log($"QA{protocol.QActionID}: |ERR: DCF Connection|Ignoring GetConnections: Invalid Format ElementKey:{request.ElementKey}", LogType.Error, LogLevel.NoLogging);
                continue;
            }
        }


        // ...

        string internalExternal = GetInternalExternalString(request.Type);

        // ...

        if (!IsElementStarted(protocol, requestElementKey))
        {
            continue;
        }

        // ...

        if (!cachedConnectionPerElement.ContainsKey(requestElementKey) || forceRefresh)
        {
            var newPolledConnections = protocol.GetConnectivityConnections(requestDMAId, requestEleId);
            if (newPolledConnections == null)
            {
                // Handle the case where GetConnectivityConnections returns null
                continue;
            }

            cachedConnectionPerElement[requestElementKey] = new FastCollection<ConnectivityConnection>(newPolledConnections.Values.ToList());
        }

        // ...

        FastCollection<ConnectivityConnection> elementConnections = cachedConnectionPerElement[requestElementKey];
        var foundConnections = FindConnections(elementConnections, indexer, uniqueKey);

        // ...

        if (request.PropertyFilter != null && result[i] != null)
        {
            // ToDo: Write code to filter on connectionProperties
        }
    }

    // Log the result or any other necessary logging
    return result;
}

private string GetInternalExternalString(ConnectionType type)
{
    switch (type)
    {
        case ConnectionType.Internal:
            return "I";
        case ConnectionType.External:
            return "E";
        case ConnectionType.Both:
            return "B";
        default:
            return "B"; // Default to "Both" if the type is not recognized.
    }
}

private ConnectivityConnection[] FindConnections(FastCollection<ConnectivityConnection> elementConnections, Expression<Func<ConnectivityConnection, object>> indexer, string uniqueKey)
{
    if (indexer != null && uniqueKey != null)
    {
        var foundConnections = elementConnections.FindValue(indexer, uniqueKey).ToArray();
        return foundConnections.Length > 0 ? foundConnections : null;
    }
    else
    {
        return elementConnections.Count() > 0 ? elementConnections.ToArray() : null;
    }
}


public bool RemoveConnections(int dataMinerID, int elementID, bool bothConnections, bool force, params int[] connectionIDs)
{
    try
    {
        if (currentConnectionsPID == -1)
        {
            protocol.Log("QA" + protocol.QActionID + "|ERR: DCF Connection|DCFHelper Error: Using RemoveConnections requires the CurrentConnectionsPID to be defined! Please change the Options Objects to include this PID", LogType.Error, LogLevel.NoLogging);
            return false;
        }

        string eleKey = CreateElementKey(dataMinerID, elementID);

        // Early return for unloaded elements
        if (unloadedElements.Contains(eleKey))
        {
            protocol.Log(string.Format("QA{0}: |ERR: DCF Connection|Ignoring RemoveConnections: Unloaded Element:{1} ", protocol.QActionID, eleKey), LogType.Error, LogLevel.NoLogging);
            return false;
        }

        HashSet<int> managedNewByThisProtocol = new HashSet<int>(newConnections.TryGetValue(eleKey, out var newSet) ? newSet : Enumerable.Empty<int>());
        HashSet<int> managedCurrentByThisProtocol = new HashSet<int>(currentConnections.TryGetValue(eleKey, out var currentSet) ? currentSet : Enumerable.Empty<int>());

        // Optimized
        foreach (int connectionID in connectionIDs)
        {
            int absConnectionID = Math.Abs(connectionID);

            if (force || managedCurrentByThisProtocol.Contains(absConnectionID) || managedNewByThisProtocol.Contains(absConnectionID))
            {
                string logMessage = $"QA{protocol.QActionID}|DCF Connection ({absConnectionID}) | Deleting Connection:{absConnectionID}";

                DebugLog(logMessage, LogType.Allways, LogLevel.NoLogging, DcfLogType.Change);

                if (protocol.DeleteConnectivityConnection(absConnectionID, dataMinerID, elementID, bothConnections))
                {
                    managedNewByThisProtocol.Remove(absConnectionID);
                    managedCurrentByThisProtocol.Remove(absConnectionID);
                }
                else
                {
                    string errorMessage = $"QA{protocol.QActionID}: |ERR: DCF Connection ({absConnectionID})| Removing DCF Connection: {absConnectionID} Returned False. Connection may not have been removed";

                    protocol.Log(errorMessage, LogType.Error, LogLevel.NoLogging);
                    finalResult = false;
                }
            }
        }

        newConnections[eleKey] = managedNewByThisProtocol;
        currentConnections[eleKey] = managedCurrentByThisProtocol;

        return finalResult;
    }
    catch (Exception e)
    {
        protocol.Log(string.Format("QA{0}:|ERR: DCF Connection| (Exception) Value at {1} with Exception:{2}", protocol.QActionID, "RemoveConnections", e.ToString()), LogType.Error, LogLevel.NoLogging);
    }

    return false;
}




public bool RemoveConnections(int dataMinerID, int elementID, bool bothConnections, bool force, params int[] connectionIDs)
{
    try
    {
        if (currentConnectionsPID == -1)
        {
            protocol.Log("QA" + protocol.QActionID + "|ERR: DCF Connection|DCFHelper Error: Using RemoveConnections requires the CurrentConnectionsPID to be defined! Please change the Options Objects to include this PID", LogType.Error, LogLevel.NoLogging);
            return false;
        }

        string eleKey = CreateElementKey(dataMinerID, elementID);

        // Early return for unloaded elements
        if (unloadedElements.Contains(eleKey))
        {
            protocol.Log(string.Format("QA{0}: |ERR: DCF Connection|Ignoring RemoveConnections: Unloaded Element:{1} ", protocol.QActionID, eleKey), LogType.Error, LogLevel.NoLogging);
            return false;
        }

        // Retrieve the managed connections sets
        if (!newConnections.TryGetValue(eleKey, out var managedNewByThisProtocol))
        {
            managedNewByThisProtocol = new HashSet<int>();
        }

        if (!currentConnections.TryGetValue(eleKey, out var managedCurrentByThisProtocol))
        {
            managedCurrentByThisProtocol = new HashSet<int>();
        }

        bool finalResult = true;

        // Create a HashSet for faster lookup
        var connectionIDsSet = new HashSet<int>(connectionIDs.Select(Math.Abs));

        foreach (int connectionID in connectionIDsSet)
        {
            if (force || managedCurrentByThisProtocol.Contains(connectionID) || managedNewByThisProtocol.Contains(connectionID))
            {
                string logMessage = $"QA{protocol.QActionID}|DCF Connection ({connectionID}) | Deleting Connection:{connectionID}";

                DebugLog(logMessage, LogType.Allways, LogLevel.NoLogging, DcfLogType.Change);

                if (protocol.DeleteConnectivityConnection(connectionID, dataMinerID, elementID, bothConnections))
                {
                    managedNewByThisProtocol.Remove(connectionID);
                    managedCurrentByThisProtocol.Remove(connectionID);
                }
                else
                {
                    string errorMessage = $"QA{protocol.QActionID}: |ERR: DCF Connection ({connectionID})| Removing DCF Connection: {connectionID} Returned False. Connection may not have been removed";

                    protocol.Log(errorMessage, LogType.Error, LogLevel.NoLogging);
                    finalResult = false;
                }
            }
        }

        newConnections[eleKey] = managedNewByThisProtocol;
        currentConnections[eleKey] = managedCurrentByThisProtocol;

        return finalResult;
    }
    catch (Exception e)
    {
        protocol.Log(string.Format("QA{0}:|ERR: DCF Connection| (Exception) Value at {1} with Exception:{2}", protocol.QActionID, "RemoveConnections", e.ToString()), LogType.Error, LogLevel.NoLogging);
    }

    return false;
}


public DcfSaveConnectionResult[] SaveConnections(bool forceRefresh, params DcfSaveConnectionRequest[] requests)
{
    DcfSaveConnectionResult[] result = new DcfSaveConnectionResult[requests.Length];
    
    for (int i = 0; i < requests.Length; i++)
    {
        DcfSaveConnectionRequest currentRequest = requests[i];
        
        // Make sure, if properties are requested, the save is synchronous.
        if (currentRequest.PropertyRequests != null && currentRequest.PropertyRequests.Count > 0)
        {
            currentRequest.Async = false;
        }

        bool updated = true;

        result[i] = new DcfSaveConnectionResult(null, null, false, true, null);

        if (currentRequest == null)
        {
            continue;
        }

        if (currentRequest.Source == null || currentRequest.Destination == null)
        {
            protocol.Log(string.Format("QA{0}: |ERR: DCF Connection|ConnectionRequest Had empty Source or Destination. The Requested Interfaces might not exist.", protocol.QActionID), LogType.Error, LogLevel.NoLogging);
            continue;
        }

        try
        {
            if (currentRequest.CustomName == null)
            {
                currentRequest.CustomName = currentRequest.Source.InterfaceName + "->" + currentRequest.Destination.InterfaceName;
            }

            string sourceElementKey = currentRequest.Source.ElementKey;
            string destinElementKey = currentRequest.Destination.ElementKey;

            if (!IsElementStarted(protocol, sourceElementKey) || !IsElementStarted(protocol, destinElementKey))
            {
                protocol.Log(string.Format("QA{0}: |ERR: DCF Connection|Ignoring ConnectionRequest due to unloaded Source or Destination Element.", protocol.QActionID), LogType.Error, LogLevel.NoLogging);
                continue;
            }

            bool internalConnection = sourceElementKey == destinElementKey;

            FastCollection<ConnectivityConnection> elementConnections = GetOrCreateElementConnections(sourceElementKey, forceRefresh);

            Expression<Func<ConnectivityConnection, object>> indexer = GetIndexerForSaveConnection(currentRequest);
            string uniqueKey = GetUniqueKeyForSaveConnection(currentRequest);

            elementConnections.AddIndex(indexer);
            ConnectivityConnection matchingConnection = elementConnections.FindValue(indexer, uniqueKey).FirstOrDefault();
            ConnectivityConnection newDestinationConnection = null;

            int sourceId = -1;
            int destinationId = -1;

            if (matchingConnection == null)
            {
                // Add a new Connection
                AddNewConnection(currentRequest, sourceElementKey, internalConnection, out sourceId, out destinationId, out newDestinationConnection, updated);
            }
            else
            {
                // Update the Connection
                UpdateExistingConnection(currentRequest, sourceElementKey, internalConnection, matchingConnection, out sourceId, out destinationId, out newDestinationConnection, updated);
            }

            result[i] = CreateDcfSaveConnectionResult(matchingConnection, newDestinationConnection, internalConnection, updated, currentRequest.PropertyRequests);

            if (currentRequest.FixedConnection)
            {
                HandleFixedConnection(sourceId, sourceElementKey);
            }
        }
        catch (Exception e)
        {
            protocol.Log(string.Format("QA{0}:|ERR: DCF Connection| Exception in SaveConnections for connectionRequest:{1}  with exception:{2}", protocol.QActionID, currentRequest.CustomName, e.ToString()), LogType.Error, LogLevel.NoLogging);
        }
    }

    return result;
}

// Helper method to get or create element connections
private FastCollection<ConnectivityConnection> GetOrCreateElementConnections(string elementKey, bool forceRefresh)
{
    if (!cachedConnectionPerElement.ContainsKey(elementKey) || forceRefresh)
    {
        var newPolledConnections = protocol.GetConnectivityConnections(currentRequest.Source.DataMinerId, currentRequest.Source.ElementId);
        
        if (newPolledConnections == null)
        {
            protocol.Log(string.Format("QA{0}: |ERR: DCF Connection|GetConnectivityConnections returned null for Element: {1}.", protocol.QActionID, elementKey), LogType.Error, LogLevel.NoLogging);
            continue;
        }

        cachedConnectionPerElement[elementKey] = new FastCollection<ConnectivityConnection>(newPolledConnections.Values.ToList());
    }

    return cachedConnectionPerElement[elementKey];
}

// Helper method to add a new connection
private void AddNewConnection(DcfSaveConnectionRequest currentRequest, string sourceElementKey, bool internalConnection, out int sourceId, out int destinationId, out ConnectivityConnection newDestinationConnection, out bool updated)
{
    if (internalConnection)
    {
        AddInternalConnection(currentRequest, sourceElementKey, out sourceId, out destinationId, out updated, out newDestinationConnection);
    }
    else
    {
        AddExternalConnection(currentRequest, sourceElementKey, out sourceId, out destinationId, out updated, out newDestinationConnection);
    }
}

// Helper method to add an internal connection
private void AddInternalConnection(DcfSaveConnectionRequest currentRequest, string sourceElementKey, out int sourceId, out int destinationId, out bool updated, out ConnectivityConnection newDestinationConnection)
{
    if (!currentRequest.Async)
    {
        if (!currentRequest.Source.AddConnection(currentRequest.CustomName, currentRequest.CustomName, currentRequest.Destination, currentRequest.ConnectionFilter, false, out sourceId, out destinationId))
        {
            HandleAddConnectionFailure(currentRequest, sourceElementKey, false, out updated);
        }

        newDestinationConnection = null;
    }
    else
    {
        if (!currentRequest.Source.AddConnection(currentRequest.CustomName, currentRequest.CustomName, currentRequest.Destination, currentRequest.ConnectionFilter, false, out sourceId, out destinationId))
        {
            HandleAddConnectionFailure(currentRequest, sourceElementKey, true, out updated);
        }

        newDestinationConnection = null;
    }
}

// Helper method to add an external connection
private void AddExternalConnection(DcfSaveConnectionRequest currentRequest, string sourceElementKey, out int sourceId, out int destinationId, out bool updated, out ConnectivityConnection newDestinationConnection)
{
    if (!currentRequest.Async)
    {
        if (!currentRequest.Source.AddConnection(currentRequest.CustomName, currentRequest.CustomName + " -RETURN", currentRequest.Destination, currentRequest.ConnectionFilter, currentRequest.CreateExternalReturn, out sourceId, out destinationId))
        {
            HandleAddConnectionFailure(currentRequest, sourceElementKey, false, out updated);
        }

        newDestinationConnection = null;
    }
    else
    {
        if (!currentRequest.Source.AddConnection(currentRequest.CustomName, currentRequest.CustomName + " -RETURN", currentRequest.Destination, currentRequest.ConnectionFilter, currentRequest.CreateExternalReturn, out sourceId, out destinationId))
        {
            HandleAddConnectionFailure(currentRequest, sourceElementKey, true, out updated);
        }

        newDestinationConnection = null;
    }
}

// Helper method to update an existing connection
private void UpdateExistingConnection(DcfSaveConnectionRequest currentRequest, string sourceElementKey, bool internalConnection, ConnectivityConnection matchingConnection, out int sourceId, out int destinationId, out ConnectivityConnection newDestinationConnection, out bool updated)
{
    sourceId = -1;
    destinationId = -1;
    updated = false;
    newDestinationConnection = null;

    if (ShouldUpdateConnection(currentRequest, sourceElementKey, matchingConnection))
    {
        if (internalConnection)
        {
            UpdateInternalConnection(currentRequest, matchingConnection, out sourceId, out destinationId, out updated, out newDestinationConnection);
        }
        else
        {
            UpdateExternalConnection(currentRequest, matchingConnection, out sourceId, out destinationId, out updated, out newDestinationConnection);
        }
    }
    else
    {
        // No update necessary
        updated = false;
        LogNoUpdateDetected(currentRequest, sourceElementKey, internalConnection);
    }
}

// Helper method to determine if an update is necessary
private bool ShouldUpdateConnection(DcfSaveConnectionRequest currentRequest, string sourceElementKey, ConnectivityConnection matchingConnection)
{
    return matchingConnection.ConnectionName != currentRequest.CustomName
        || matchingConnection.SourceDataMinerId + "/" + matchingConnection.SourceElementId != currentRequest.Source.ElementKey
        || matchingConnection.SourceInterfaceId != currentRequest.Source.InterfaceId
        || matchingConnection.DestinationDMAId + "/" + matchingConnection.DestinationEId != currentRequest.Destination.ElementKey
        || matchingConnection.DestinationInterfaceId != currentRequest.Destination.InterfaceId
        || matchingConnection.ConnectionFilter != currentRequest.ConnectionFilter;
}

// Helper method to update an internal connection
private void UpdateInternalConnection(DcfSaveConnectionRequest currentRequest, ConnectivityConnection matchingConnection, out int sourceId, out int destinationId, out bool updated, out ConnectivityConnection newDestinationConnection)
{
    if (!matchingConnection.Update(currentRequest.CustomName, currentRequest.Source.InterfaceId, currentRequest.CustomName, currentRequest.Destination.DataMinerId, currentRequest.Destination.ElementId, currentRequest.Destination.InterfaceId, currentRequest.ConnectionFilter, false, out newDestinationConnection, 420000))
    {
        HandleUpdateConnectionFailure(currentRequest, false, out sourceId, out destinationId, out updated);
    }
    else
    {
        sourceId = matchingConnection.ConnectionId;
        destinationId = newDestinationConnection?.ConnectionId ?? -1;
        updated = true;
    }
}

// Helper method to update an external connection
private void UpdateExternalConnection(DcfSaveConnectionRequest currentRequest, ConnectivityConnection matchingConnection, out int sourceId, out int destinationId, out bool updated, out ConnectivityConnection newDestinationConnection)
{
    if (!matchingConnection.Update(currentRequest.CustomName, currentRequest.Source.InterfaceId, currentRequest.CustomName + " -RETURN", currentRequest.Destination.DataMinerId, currentRequest.Destination.ElementId, currentRequest.Destination.InterfaceId, currentRequest.ConnectionFilter, currentRequest.CreateExternalReturn, out newDestinationConnection, 420000))
    {
        HandleUpdateConnectionFailure(currentRequest, true, out sourceId, out destinationId, out updated);
    }
    else
    {
        sourceId = matchingConnection.ConnectionId;
        destinationId = newDestinationConnection?.ConnectionId ?? -1;
        updated = true;
    }
}

// Helper method to create a DcfSaveConnectionResult
private DcfSaveConnectionResult CreateDcfSaveConnectionResult(ConnectivityConnection matchingConnection, ConnectivityConnection newDestinationConnection, bool internalConnection, bool updated, IEnumerable<DcfSaveConnectionPropertyRequest> propertyRequests)
{
    DcfSaveConnectionPropertyResult[] propertyResults = null;

    if (propertyRequests != null && propertyRequests.Any())
    {
        propertyResults = SaveConnectionProperties(matchingConnection, propertyRequests.ToArray());
    }

    if (matchingConnection == null && newDestinationConnection == null)
    {
        return new DcfSaveConnectionResult(-1, -1, internalConnection, updated, propertyResults);
    }
    else
    {
        return new DcfSaveConnectionResult(matchingConnection, newDestinationConnection, internalConnection, updated, propertyResults);
    }
}

// Other helper methods for various operations...


public bool RemoveConnections(int dataMinerID, int elementID, bool bothConnections, bool force, params int[] connectionIDs)
{
    try
    {
        if (currentConnectionsPID == -1)
        {
            protocol.Log("QA" + protocol.QActionID + "|ERR: DCF Connection|DCFHelper Error: Using RemoveConnections requires the CurrentConnectionsPID to be defined! Please change the Options Objects to include this PID", LogType.Error, LogLevel.NoLogging);
            return false;
        }

        string eleKey = CreateElementKey(dataMinerID, elementID);

        // Early return for unloaded elements
        if (unloadedElements.Contains(eleKey))
        {
            protocol.Log(string.Format("QA{0}: |ERR: DCF Connection|Ignoring RemoveConnections: Unloaded Element:{1} ", protocol.QActionID, eleKey), LogType.Error, LogLevel.NoLogging);
            return false;
        }

        HashSet<int> managedNewByThisProtocol = new HashSet<int>(newConnections.TryGetValue(eleKey, out var newSet) ? newSet : Enumerable.Empty<int>());
        HashSet<int> managedCurrentByThisProtocol = new HashSet<int>(currentConnections.TryGetValue(eleKey, out var currentSet) ? currentSet : Enumerable.Empty<int>());

        // Optimized
        foreach (int connectionID in connectionIDs)
        {
            int absConnectionID = Math.Abs(connectionID);

            if (force || managedCurrentByThisProtocol.Contains(absConnectionID) || managedNewByThisProtocol.Contains(absConnectionID))
            {
                string logMessage = $"QA{protocol.QActionID}|DCF Connection ({absConnectionID}) | Deleting Connection:{absConnectionID}";

                DebugLog(logMessage, LogType.Allways, LogLevel.NoLogging, DcfLogType.Change);

                if (protocol.DeleteConnectivityConnection(absConnectionID, dataMinerID, elementID, bothConnections))
                {
                    managedNewByThisProtocol.Remove(absConnectionID);
                    managedCurrentByThisProtocol.Remove(absConnectionID);
                }
                else
                {
                    string errorMessage = $"QA{protocol.QActionID}: |ERR: DCF Connection ({absConnectionID})| Removing DCF Connection: {absConnectionID} Returned False. Connection may not have been removed";

                    protocol.Log(errorMessage, LogType.Error, LogLevel.NoLogging);
                    finalResult = false;
                }
            }
        }

        newConnections[eleKey] = managedNewByThisProtocol;
        currentConnections[eleKey] = managedCurrentByThisProtocol;

        return finalResult;
    }
    catch (Exception e)
    {
        protocol.Log(string.Format("QA{0}:|ERR: DCF Connection| (Exception) Value at {1} with Exception:{2}", protocol.QActionID, "RemoveConnections", e.ToString()), LogType.Error, LogLevel.NoLogging);
    }

    return false;
}


public DcfSaveConnectionResult[] SaveConnections(bool forceRefresh, params DcfSaveConnectionRequest[] requests)
{
    DcfSaveConnectionResult[] result = new DcfSaveConnectionResult[requests.Length];

    // Fetch all necessary data in bulk
    Dictionary<string, FastCollection<ConnectivityConnection>> cachedConnections = new Dictionary<string, FastCollection<ConnectivityConnection>>();

    foreach (DcfSaveConnectionRequest currentRequest in requests)
    {
        string sourceElementKey = currentRequest.Source.ElementKey;

        if (!cachedConnections.ContainsKey(sourceElementKey) || forceRefresh)
        {
            var newPolledConnections = protocol.GetConnectivityConnections(currentRequest.Source.DataMinerId, currentRequest.Source.ElementId);
            if (newPolledConnections == null)
            {
                protocol.Log(string.Format("QA{0}: |ERR: DCF Connection|GetConnectivityConnections returned a Null for Element:" + currentRequest.Source.DataMinerId + "/" + currentRequest.Source.ElementId + " Either there was No Response, SLNet was not available, or there was an Exception in the DataMiner DCF API code.", protocol.QActionID), LogType.Error, LogLevel.NoLogging);
                continue;
            }

            cachedConnections[sourceElementKey] = new FastCollection<ConnectivityConnection>(newPolledConnections.Values.ToList());
        }
    }

    for (int i = 0; i < requests.Length; i++)
    {
        DcfSaveConnectionRequest currentRequest = requests[i];

        string sourceElementKey = currentRequest.Source.ElementKey;

        // Instead of making SLNet calls here, use the cached data from bulk fetch
        FastCollection<ConnectivityConnection> elementConnections;
        if (!cachedConnections.TryGetValue(sourceElementKey, out elementConnections))
        {
            // Handle the case where the element key is not found in the cache
            // You might want to log an error or take appropriate action.
            continue;
        }

        // ... Rest of your code ...

        // Continue with your code using the cached data from elementConnections
    }

    return result;
}



public DcfSaveConnectionResult[] SaveConnections(
      bool forceRefresh,
      params DcfSaveConnectionRequest[] requests)
    {
      DcfSaveConnectionResult[] connectionResultArray = new DcfSaveConnectionResult[requests.Length];
      for (int index = 0; index < requests.Length; ++index)
      {
        DcfSaveConnectionRequest request = requests[index];
        if (request.PropertyRequests != null && request.PropertyRequests.Count > 0)
          request.Async = false;
        connectionResultArray[index] = new DcfSaveConnectionResult((ConnectivityConnection) null, (ConnectivityConnection) null, false, true, (DcfSaveConnectionPropertyResult[]) null);
        bool updated = true;
        if (request != null)
        {
          if (request.Source == null || request.Destination == null)
          {
            this.protocol.Log(string.Format("QA{0}: |ERR: DCF Connection|ConnectionRequest Had empty Source or Destination. The Requested Interfaces might not exist.", (object) this.protocol.QActionID), (LogType) 2, (LogLevel) 0);
          }
          else
          {
            try
            {
              if (request.CustomName == null)
                request.CustomName = request.Source.InterfaceName + "->" + request.Destination.InterfaceName;
              string elementKey1 = request.Source.ElementKey;
              if (!this.IsElementStarted(this.protocol, elementKey1))
              {
                this.protocol.Log(string.Format("QA{0}: |ERR: DCF Connection|Ignoring ConnectionRequest Unloaded Source Element:{1} ", (object) this.protocol.QActionID, (object) elementKey1), (LogType) 2, (LogLevel) 0);
              }
              else
              {
                string elementKey2 = request.Destination.ElementKey;
                if (!this.IsElementStarted(this.protocol, elementKey2))
                {
                  this.protocol.Log(string.Format("QA{0}: |ERR: DCF Connection|Ignoring ConnectionRequest Unloaded Destination Element:{1} ", (object) this.protocol.QActionID, (object) elementKey2), (LogType) 2, (LogLevel) 0);
                }
                else
                {
                  bool internalConnection = elementKey1 == elementKey2;
                  if (!this.cachedConnectionPerElement.ContainsKey(elementKey1) | forceRefresh)
                  {
                    Dictionary<int, ConnectivityConnection> connectivityConnections = this.protocol.GetConnectivityConnections(request.Source.DataMinerId, request.Source.ElementId);
                    if (connectivityConnections == null)
                    {
                      this.protocol.Log(string.Format("QA{0}: |ERR: DCF Connection|GetConnectivityConnections returned a Null for Element:" + request.Source.DataMinerId.ToString() + "/" + request.Source.ElementId.ToString() + " Either there was No Response, SLNet was not available, or there was an Exception in the DataMiner DCF API code.", (object) this.protocol.QActionID), (LogType) 2, (LogLevel) 0);
                      continue;
                    }
                    this.cachedConnectionPerElement[elementKey1] = new FastCollection<ConnectivityConnection>((IList<ConnectivityConnection>) connectivityConnections.Values.ToList<ConnectivityConnection>());
                  }
                  FastCollection<ConnectivityConnection> fastCollection = this.cachedConnectionPerElement[elementKey1];
                  Expression<Func<ConnectivityConnection, object>> property;
                  string str1;
                  switch (request.ConnectionType)
                  {
                    case SaveConnectionType.Unique_Source:
                      ParameterExpression parameterExpression1;
                      // ISSUE: method reference
                      // ISSUE: method reference
                      property = Expression.Lambda<Func<ConnectivityConnection, object>>((Expression) Expression.Add(this.InternalExternalChar(p) + "_", (Expression) Expression.Convert((Expression) Expression.Property((Expression) parameterExpression1, (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (ConnectivityConnection.get_SourceInterfaceId))), typeof (object)), (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (string.Concat))), parameterExpression1);
                      str1 = this.InternalExternalChar(request) + "_" + Convert.ToString(request.Source.InterfaceId);
                      break;
                    case SaveConnectionType.Unique_Destination:
                      ParameterExpression parameterExpression2;
                      // ISSUE: method reference
                      // ISSUE: method reference
                      // ISSUE: method reference
                      // ISSUE: method reference
                      // ISSUE: method reference
                      // ISSUE: method reference
                      // ISSUE: method reference
                      // ISSUE: method reference
                      property = Expression.Lambda<Func<ConnectivityConnection, object>>((Expression) Expression.Add((Expression) Expression.Add((Expression) Expression.Add((Expression) Expression.Add((Expression) Expression.Add(this.InternalExternalChar(p) + "_", (Expression) Expression.Convert((Expression) Expression.Property((Expression) parameterExpression2, (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (ConnectivityConnection.get_DestinationDMAId))), typeof (object)), (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (string.Concat))), (Expression) Expression.Constant((object) "/", typeof (string)), (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (string.Concat))), (Expression) Expression.Convert((Expression) Expression.Property((Expression) parameterExpression2, (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (ConnectivityConnection.get_DestinationEId))), typeof (object)), (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (string.Concat))), (Expression) Expression.Constant((object) "/", typeof (string)), (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (string.Concat))), (Expression) Expression.Convert((Expression) Expression.Property((Expression) parameterExpression2, (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (ConnectivityConnection.get_DestinationInterfaceId))), typeof (object)), (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (string.Concat))), parameterExpression2);
                      string[] strArray = new string[7]
                      {
                        this.InternalExternalChar(request),
                        "_",
                        request.Destination.DataMinerId.ToString(),
                        "/",
                        null,
                        null,
                        null
                      };
                      int num1 = request.Destination.ElementId;
                      strArray[4] = num1.ToString();
                      strArray[5] = "/";
                      num1 = request.Destination.InterfaceId;
                      strArray[6] = num1.ToString();
                      str1 = string.Concat(strArray);
                      break;
                    case SaveConnectionType.Unique_Name:
                      ParameterExpression parameterExpression3;
                      // ISSUE: method reference
                      // ISSUE: method reference
                      property = Expression.Lambda<Func<ConnectivityConnection, object>>((Expression) Expression.Add(this.InternalExternalChar(p) + "_", (Expression) Expression.Property((Expression) parameterExpression3, (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (ConnectivityConnection.get_ConnectionName))), (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (string.Concat))), parameterExpression3);
                      str1 = this.InternalExternalChar(request) + "_" + request.CustomName;
                      break;
                    case SaveConnectionType.Unique_SourceAndDestination:
                      ParameterExpression parameterExpression4;
                      // ISSUE: method reference
                      // ISSUE: method reference
                      // ISSUE: method reference
                      // ISSUE: method reference
                      // ISSUE: method reference
                      // ISSUE: method reference
                      // ISSUE: method reference
                      // ISSUE: method reference
                      // ISSUE: method reference
                      // ISSUE: method reference
                      // ISSUE: method reference
                      property = Expression.Lambda<Func<ConnectivityConnection, object>>((Expression) Expression.Add((Expression) Expression.Add((Expression) Expression.Add((Expression) Expression.Add((Expression) Expression.Add((Expression) Expression.Add((Expression) Expression.Add(this.InternalExternalChar(p) + "_", (Expression) Expression.Convert((Expression) Expression.Property((Expression) parameterExpression4, (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (ConnectivityConnection.get_SourceInterfaceId))), typeof (object)), (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (string.Concat))), (Expression) Expression.Constant((object) "/", typeof (string)), (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (string.Concat))), (Expression) Expression.Convert((Expression) Expression.Property((Expression) parameterExpression4, (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (ConnectivityConnection.get_DestinationDMAId))), typeof (object)), (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (string.Concat))), (Expression) Expression.Constant((object) "/", typeof (string)), (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (string.Concat))), (Expression) Expression.Convert((Expression) Expression.Property((Expression) parameterExpression4, (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (ConnectivityConnection.get_DestinationEId))), typeof (object)), (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (string.Concat))), (Expression) Expression.Constant((object) "/", typeof (string)), (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (string.Concat))), (Expression) Expression.Convert((Expression) Expression.Property((Expression) parameterExpression4, (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (ConnectivityConnection.get_DestinationInterfaceId))), typeof (object)), (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (string.Concat))), parameterExpression4);
                      str1 = this.InternalExternalChar(request) + "_" + request.Source.InterfaceId.ToString() + "/" + request.Destination.ElementKey + "/" + request.Destination.InterfaceId.ToString();
                      break;
                    default:
                      ParameterExpression parameterExpression5;
                      // ISSUE: method reference
                      // ISSUE: method reference
                      property = Expression.Lambda<Func<ConnectivityConnection, object>>((Expression) Expression.Add(this.InternalExternalChar(p) + "_", (Expression) Expression.Property((Expression) parameterExpression5, (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (ConnectivityConnection.get_ConnectionName))), (MethodInfo) MethodBase.GetMethodFromHandle(__methodref (string.Concat))), parameterExpression5);
                      str1 = this.InternalExternalChar(request) + "_" + request.CustomName;
                      break;
                  }
                  fastCollection.AddIndex(property);
                  ConnectivityConnection connectivityConnection = fastCollection.FindValue<object>(property, (object) str1).FirstOrDefault<ConnectivityConnection>();
                  ConnectivityConnection destinationConnection = (ConnectivityConnection) null;
                  int num2 = -1;
                  int destinationConnectionID = -1;
                  bool flag = true;
                  string str2 = internalConnection ? "Internal" : "External";
                  string elementKey3 = request.Source.ElementKey;
                  string elementKey4 = request.Destination.ElementKey;
                  string message1 = string.Format("QA{0}|DCF Connection|Adding {1} Connection:{2} | With Connection Filter: {3}", (object) this.protocol.QActionID, (object) str2, (object) request.CustomName, (object) request.ConnectionFilter);
                  if (!internalConnection)
                    message1 = message1 + " | from Element:" + elementKey3 + " To Element:" + elementKey4;
                  this.DebugLog(message1, (LogType) 8, (LogLevel) 0, DcfLogType.Change);
                  if (connectivityConnection == null)
                  {
                    if (!(request.Async ? (internalConnection ? request.Source.AddConnection(request.CustomName, request.CustomName, request.Destination, request.ConnectionFilter, false, ref num2, ref destinationConnectionID) : request.Source.AddConnection(request.CustomName, request.CustomName + " -RETURN", request.Destination, request.ConnectionFilter, request.CreateExternalReturn, ref num2, ref destinationConnectionID)) : (internalConnection ? request.Source.AddConnection(request.CustomName, request.CustomName, request.Destination, request.ConnectionFilter, false, ref connectivityConnection, ref destinationConnection, 420000) : request.Source.AddConnection(request.CustomName, request.CustomName + " -RETURN", request.Destination, request.ConnectionFilter, request.CreateExternalReturn, ref connectivityConnection, ref destinationConnection, 420000))))
                    {
                      string str3 = internalConnection ? "-sync" : "-async";
                      string str4;
                      if (!internalConnection)
                        str4 = string.Format("QA{0}:|ERR: DCF Connection|Adding External DCF Connection:{1} from element {2} to element {3} Timed-Out after 7 minutes or returned false. Connection may not have been added", (object) this.protocol.QActionID, (object) request.CustomName, (object) elementKey3, (object) elementKey4);
                      else
                        str4 = string.Format("QA{0}: |ERR: DCF Connection|Adding {1} DCF Connection{2}:{3} on element {4} Timed-Out after 7 minutes or returned false. Connection may not have been added", (object) this.protocol.QActionID, (object) str2, (object) str3, (object) request.CustomName, (object) elementKey3);
                      this.protocol.Log(str4, (LogType) 2, (LogLevel) 0);
                    }
                  }
                  else
                  {
                    int num3;
                    if (!(connectivityConnection.ConnectionName != request.CustomName))
                    {
                      string str5 = connectivityConnection.SourceDataMinerId.ToString();
                      int num4 = connectivityConnection.SourceElementId;
                      string str6 = num4.ToString();
                      if (!(str5 + "/" + str6 != elementKey3) && connectivityConnection.SourceInterfaceId == request.Source.InterfaceId)
                      {
                        num4 = connectivityConnection.DestinationDMAId;
                        string str7 = num4.ToString();
                        num4 = connectivityConnection.DestinationEId;
                        string str8 = num4.ToString();
                        if (!(str7 + "/" + str8 != elementKey4) && connectivityConnection.DestinationInterfaceId == request.Destination.InterfaceId)
                        {
                          num3 = connectivityConnection.ConnectionFilter != request.ConnectionFilter ? 1 : 0;
                          goto label_35;
                        }
                      }
                    }
                    num3 = 1;
label_35:
                    if (num3 == 0)
                    {
                      flag = false;
                      string str9 = internalConnection ? "Internal" : "External";
                      string message2;
                      if (!internalConnection)
                        message2 = string.Format("QA{0}|DCF Connection ({1}) | Not Updating {2} Connection (ID:{3}) To:{4} from Element:{5} To Element:{6} -- No Change Detected", (object) this.protocol.QActionID, (object) connectivityConnection.ConnectionId, (object) str9, (object) connectivityConnection.ConnectionId, (object) request.CustomName, (object) elementKey3, (object) elementKey4);
                      else
                        message2 = string.Format("QA{0}|DCF Connection ({1}) | Not Updating {2} Connection (ID:{3}) To:{4} on Element:{5} -- No Change Detected", (object) this.protocol.QActionID, (object) connectivityConnection.ConnectionId, (object) str9, (object) connectivityConnection.ConnectionId, (object) request.CustomName, (object) elementKey3);
                      this.DebugLog(message2, (LogType) 8, (LogLevel) 0, DcfLogType.Same);
                    }
                    else
                    {
                      string str10 = internalConnection ? "Internal" : "External";
                      string message3;
                      if (!internalConnection)
                        message3 = string.Format("QA{0}|DCF Connection ({1}) | Updating {2} Connection (ID:{3}) To:{4} | With Connection Filter: {5} | from Element:{6} To Element:{7}", (object) this.protocol.QActionID, (object) connectivityConnection.ConnectionId, (object) str10, (object) connectivityConnection.ConnectionId, (object) request.CustomName, (object) request.ConnectionFilter, (object) elementKey3, (object) elementKey4);
                      else
                        message3 = string.Format("QA{0}|DCF Connection ({1}) | Updating {2} Connection (ID:{3}) To:{4} | With Connection Filter: {5} | on Element:{6}", (object) this.protocol.QActionID, (object) connectivityConnection.ConnectionId, (object) str10, (object) connectivityConnection.ConnectionId, (object) request.CustomName, (object) request.ConnectionFilter, (object) elementKey3);
                      this.DebugLog(message3, (LogType) 8, (LogLevel) 0, DcfLogType.Change);
                      if (!(internalConnection ? connectivityConnection.Update(request.CustomName, request.Source.InterfaceId, request.CustomName, request.Destination.DataMinerId, request.Destination.ElementId, request.Destination.InterfaceId, request.ConnectionFilter, false, ref destinationConnection, 420000) : connectivityConnection.Update(request.CustomName, request.Source.InterfaceId, request.CustomName + " -RETURN", request.Destination.DataMinerId, request.Destination.ElementId, request.Destination.InterfaceId, request.ConnectionFilter, request.CreateExternalReturn, ref destinationConnection, 420000)))
                      {
                        string str11 = internalConnection ? "Internal" : "External";
                        string str12;
                        if (!internalConnection)
                          str12 = string.Format("QA{0}|ERR: DCF Connection ({1}) | Updating {2} DCF Connection:{3} from element {4} to element {5} Timed-Out after 7 minutes or returned false. Connection may not have been updated", (object) this.protocol.QActionID, (object) connectivityConnection.ConnectionId, (object) str11, (object) request.CustomName, (object) elementKey3, (object) elementKey4);
                        else
                          str12 = string.Format("QA{0}|ERR: DCF Connection ({1}) | Updating {2} DCF Connection:{3} on element {4} Timed-Out after 7 minutes or returned false. Connection may not have been updated", (object) this.protocol.QActionID, (object) connectivityConnection.ConnectionId, (object) str11, (object) request.CustomName, (object) elementKey3);
                        this.protocol.Log(str12, (LogType) 2, (LogLevel) 0);
                      }
                    }
                  }
                  if (connectivityConnection != null)
                    num2 = connectivityConnection.ConnectionId;
                  if (destinationConnection != null)
                    destinationConnectionID = destinationConnection.ConnectionId;
                  SLProtocol protocol1 = this.protocol;
                  int qactionId = this.protocol.QActionID;
                  string str13 = "QA" + qactionId.ToString() + "|TEMPORARY|4";
                  protocol1.Log(str13, (LogType) 2, (LogLevel) 0);
                  string elementKey5 = DcfHelper.CreateElementKey(request.Source.DataMinerId, request.Source.ElementId);
                  if (request.FixedConnection)
                  {
                    if (num2 != -1)
                      DcfHelper.AddToPropertyDictionary(this.newConnections, elementKey5, num2 * -1);
                  }
                  else
                  {
                    SLProtocol protocol2 = this.protocol;
                    qactionId = this.protocol.QActionID;
                    string str14 = "QA" + qactionId.ToString() + "|TEMPORARY|5";
                    protocol2.Log(str14, (LogType) 2, (LogLevel) 0);
                    DcfHelper.AddToPropertyDictionary(this.newConnections, elementKey5, num2);
                    SLProtocol protocol3 = this.protocol;
                    qactionId = this.protocol.QActionID;
                    string str15 = "QA" + qactionId.ToString() + "|TEMPORARY|6";
                    protocol3.Log(str15, (LogType) 2, (LogLevel) 0);
                  }
                  SLProtocol protocol4 = this.protocol;
                  qactionId = this.protocol.QActionID;
                  string str16 = "QA" + qactionId.ToString() + "|TEMPORARY|6.1";
                  protocol4.Log(str16, (LogType) 2, (LogLevel) 0);
                  DcfSaveConnectionPropertyResult[] propertyResults = (DcfSaveConnectionPropertyResult[]) null;
                  if (request.PropertyRequests != null && request.PropertyRequests.Count<DcfSaveConnectionPropertyRequest>() > 0)
                  {
                    SLProtocol protocol5 = this.protocol;
                    qactionId = this.protocol.QActionID;
                    string str17 = "QA" + qactionId.ToString() + "|TEMPORARY|6.2";
                    protocol5.Log(str17, (LogType) 2, (LogLevel) 0);
                    if (!request.Async)
                    {
                      SLProtocol protocol6 = this.protocol;
                      qactionId = this.protocol.QActionID;
                      string str18 = "QA" + qactionId.ToString() + "|TEMPORARY|7";
                      protocol6.Log(str18, (LogType) 2, (LogLevel) 0);
                      propertyResults = this.SaveConnectionProperties(connectivityConnection, request.PropertyRequests.ToArray());
                    }
                    else
                    {
                      SLProtocol protocol7 = this.protocol;
                      qactionId = this.protocol.QActionID;
                      string str19 = "QA" + qactionId.ToString() + "|TEMPORARY|6.2.1";
                      protocol7.Log(str19, (LogType) 2, (LogLevel) 0);
                      if (connectivityConnection == null)
                      {
                        SLProtocol protocol8 = this.protocol;
                        qactionId = this.protocol.QActionID;
                        string str20 = "QA" + qactionId.ToString() + "|TEMPORARY|MatchCon null";
                        protocol8.Log(str20, (LogType) 2, (LogLevel) 0);
                      }
                      this.protocol.Log(string.Format("QA{0}:|ERR: DCF Connection (" + num2.ToString() + ") | Saving Properties on an Async created connection is not supported. Please use synchronous SaveConnections", (object) this.protocol.QActionID), (LogType) 2, (LogLevel) 0);
                      SLProtocol protocol9 = this.protocol;
                      qactionId = this.protocol.QActionID;
                      string str21 = "QA" + qactionId.ToString() + "|TEMPORARY|6.2.1.1";
                      protocol9.Log(str21, (LogType) 2, (LogLevel) 0);
                    }
                  }
                  SLProtocol protocol10 = this.protocol;
                  qactionId = this.protocol.QActionID;
                  string str22 = "QA" + qactionId.ToString() + "|TEMPORARY|6.3";
                  protocol10.Log(str22, (LogType) 2, (LogLevel) 0);
                  if (connectivityConnection == null && destinationConnection == null)
                  {
                    SLProtocol protocol11 = this.protocol;
                    qactionId = this.protocol.QActionID;
                    string str23 = "QA" + qactionId.ToString() + "|TEMPORARY|8";
                    protocol11.Log(str23, (LogType) 2, (LogLevel) 0);
                    connectionResultArray[index] = new DcfSaveConnectionResult(num2, destinationConnectionID, internalConnection, updated, propertyResults);
                    SLProtocol protocol12 = this.protocol;
                    qactionId = this.protocol.QActionID;
                    string str24 = "QA" + qactionId.ToString() + "|TEMPORARY|9";
                    protocol12.Log(str24, (LogType) 2, (LogLevel) 0);
                  }
                  else
                  {
                    SLProtocol protocol13 = this.protocol;
                    qactionId = this.protocol.QActionID;
                    string str25 = "QA" + qactionId.ToString() + "|TEMPORARY|10";
                    protocol13.Log(str25, (LogType) 2, (LogLevel) 0);
                    connectionResultArray[index] = new DcfSaveConnectionResult(connectivityConnection, destinationConnection, internalConnection, updated, propertyResults);
                    SLProtocol protocol14 = this.protocol;
                    qactionId = this.protocol.QActionID;
                    string str26 = "QA" + qactionId.ToString() + "|TEMPORARY|11";
                    protocol14.Log(str26, (LogType) 2, (LogLevel) 0);
                  }
                }
              }
            }
            catch (Exception ex)
            {
              this.protocol.Log(string.Format("QA{0}:|ERR: DCF Connection| Exception in SaveConnections for connectionRequest:{1}  with exception:{2}", (object) this.protocol.QActionID, (object) request.CustomName, (object) ex.ToString()), (LogType) 2, (LogLevel) 0);
            }
          }
        }
      }
      return connectionResultArray;
    }








    public bool RemoveConnections(int dataMinerID, int elementID, bool bothConnections, bool force, params int[] connectionIDs)
        {
            try
            {
                if (currentConnectionsPID == -1)
                {
                    protocol.Log("QA" + protocol.QActionID + "|ERR: DCF Connection|DCFHelper Error: Using RemoveConnections requires the CurrentConnectionsPID to be defined! Please change the Options Objects to include this PID", LogType.Error, LogLevel.NoLogging);
                    return false;
                }

                bool finalResult = true;
                string eleKey = CreateElementKey(dataMinerID, elementID);

                // Early return for unloaded elements
                if (unloadedElements.Contains(eleKey))
                {
                    protocol.Log(string.Format("QA{0}: |ERR: DCF Connection|Ignoring RemoveConnections: Unloaded Element:{1} ", protocol.QActionID, eleKey), LogType.Error, LogLevel.NoLogging);
                    return false;
                }

                HashSet<int> managedNewByThisProtocol = new HashSet<int>(newConnections.TryGetValue(eleKey, out var newSet) ? newSet : Enumerable.Empty<int>());
                HashSet<int> managedCurrentByThisProtocol = new HashSet<int>(currentConnections.TryGetValue(eleKey, out var currentSet) ? currentSet : Enumerable.Empty<int>());

                // Optimized
                foreach (int connectionID in connectionIDs)
                {
                    int absConnectionID = Math.Abs(connectionID);

                    if (force || managedCurrentByThisProtocol.Contains(absConnectionID) || managedNewByThisProtocol.Contains(absConnectionID))
                    {
                        string logMessage = $"QA{protocol.QActionID}|DCF Connection ({absConnectionID}) | Deleting Connection:{absConnectionID}";

                        DebugLog(logMessage, LogType.Allways, LogLevel.NoLogging, DcfLogType.Change);

                        if (protocol.DeleteConnectivityConnection(absConnectionID, dataMinerID, elementID, bothConnections))
                        {
                            managedNewByThisProtocol.Remove(absConnectionID);
                            managedCurrentByThisProtocol.Remove(absConnectionID);
                        }
                        else
                        {
                            string errorMessage = $"QA{protocol.QActionID}: |ERR: DCF Connection ({absConnectionID})| Removing DCF Connection: {absConnectionID} Returned False. Connection may not have been removed";

                            protocol.Log(errorMessage, LogType.Error, LogLevel.NoLogging);
                            finalResult = false;
                        }
                    }
                }

                newConnections[eleKey] = managedNewByThisProtocol;
                currentConnections[eleKey] = managedCurrentByThisProtocol;

                return finalResult;
            }
            catch (Exception e)
            {
                protocol.Log(string.Format("QA{0}:|ERR: DCF Connection| (Exception) Value at {1} with Exception:{2}", protocol.QActionID, "RemoveConnections", e.ToString()), LogType.Error, LogLevel.NoLogging);
            }

            return false;
        }
